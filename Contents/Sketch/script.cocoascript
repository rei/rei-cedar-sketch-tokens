var sketch = require('sketch');
var platformTokens = require('./platform-tokens.js')
var typography = require('./new-typo.js')
var prominence = require('./prominence.js')

// const documnet = sketch.getSelectedDocument()

var overwriteAll = function (context) {
  overwriteColors()
  overwriteTextStyles()
  overwriteLayerStyles()
}
var addAll = function (context) {
  addColors()
  addTextStyles()
  addLayerStyles()
}

function overwriteColors(context) {
  sketch.getSelectedDocument().colors = generateColors();
}

function addColors(context) {
  // sketch.getSelectedDocument().colors.push(generateColors()) // TODO: TEST
  sketch.getSelectedDocument().colors.push(...generateColors()) // TODO: TEST
}

function overwriteTextStyles(context) {
  sketch.getSelectedDocument().sharedTextStyles = generateTextStyles();
}

function addTextStyles(context) {
  // sketch.getSelectedDocument().sharedTextStyles.push(generateTextStyles()) // TODO: TEST
  sketch.getSelectedDocument().sharedTextStyles.push(...generateTextStyles()) // TODO: TEST
}

function overwriteLayerStyles(context) {
  sketch.getSelectedDocument().sharedLayerStyles = generateLayerStyles()
}

function addLayerStyles(context) {
  // sketch.getSelectedDocument().sharedTextStyles.push(generateLayerStyles()) // TODO: TEST
  sketch.getSelectedDocument().sharedTextStyles.push(...generateLayerStyles()) // TODO: TEST
}

function generateColors() {
  return platformTokens.global.colors.map(color => ({
    name: cssNameToSketch(color.name.substring(10)),
    color: color.value
  }))
}

function generateTextStyles(context) {
  const textTokens = [];
  const typoColors = platformTokens.global.colors.filter(color => color.docs.type === 'text')
  const typoAlignment = [
    {
      name: 'left',
      value: sketch.Text.Alignment.left
    },
    {
      name: 'center',
      value: sketch.Text.Alignment.center
    },
    {
      name: 'right',
      value: sketch.Text.Alignment.right
    },
  ]
  typography.forEach(typoStyle => {
    typoColors.forEach(typoColor => {
      const typoColorName = typoColor.name.substring(15)
      typoAlignment.forEach(typoAlign => {
        const styleName = `${typoStyle.name.substring(9)}-${typoColorName}-${typoAlign.name}`
        textTokens.push({
          name: cssNameToSketch(styleName),
          style: {
            lineHeight: typoStyle.value.line,
            fontSize: typoStyle.value.size,
            fontFamily: typoStyle.value.family,
            fontWeight: typoStyle.value.weight,
            textColor: typoColor.value,
            alignment: typoAlign.value,
            textTransform: typoStyle.value.transform,
            borders: []
          }
        })
      })
    })
  })
  return textTokens
}

function generateLayerStyles() {
  let layerStyles = platformTokens.global.colors
    // .filter(color=>color.docs.type !== 'text') // keeping text styles for flexibility
    .map(color => {
      return {
        name: cssNameToSketch(color.name.substring(10)),
        style: {
          fills: color.docs.type === 'border' ? [] : [{
            color: color.value,
          }],
          borders: color.docs.type !== 'border' ? [] : [{
            color: color.value,
            position: sketch.Style.BorderPosition.Inside
          }],
        }
      }
    })
  layerStyles = layerStyles.concat(prominence.map(prom => {
    return {
      name: cssNameToSketch(prom.name.substring(4)),
      style: {
        shadows: prom.value,
        borders: []
      }
    }
  }))
  return layerStyles
}

// UTIL FUNCTIONS // 
const cssNameToSketch = string => string.split('-').map(substring => stringCapitalizeFistLetter(substring)).join('/')
const stringCapitalizeFistLetter = string => string.charAt(0).toUpperCase() + string.slice(1)
