var sketch = require('sketch');
var colors = require('./colors.js').color
var colorValues = require('./colorValues.js')
var platformTokens = require('./platform-tokens.js')
var typography = require('./new-typo.js')
// @import "colors.json5";
console.log(colors)

var onRun = function (context) {

  // console.log(buildTokens(colors, 'color-'));
  // console.log(sketch.getSelectedDocument());

  // GENERATE COLORS //
  const colorTokens = platformTokens.global.colors.map(color => ({
      name: cssNameToSketch(color.name.substring(10)),
      color: color.value
  }))
  sketch.getSelectedDocument().colors = colorTokens;

  // GENERATE TEXT STYLES //
  const textTokens = [];
  typoColors = [
    {
      name: 'darkmode',
      value: '#FAFAFA'
    },
    {
      name: 'lightmode',
      value: '#292929'
    },
  ]
  typoAlignment = [
    {
      name: 'left',
      value: sketch.Text.Alignment.left
    },
    {
      name: 'center',
      value: sketch.Text.Alignment.center
    },
    {
      name: 'right',
      value: sketch.Text.Alignment.right
    },
  ]
  typography.forEach(typoStyle => {
    typoColors.forEach(typoColor =>{
      typoAlignment.forEach(typoAlign => {
        const styleName = typoStyle.name.substring(9) + `-${typoColor.name}-${typoAlign.name}`
        textTokens.push({
          name: cssNameToSketch(styleName),
          style: {
            lineHeight: typoStyle.value.line,
            fontSize: typoStyle.value.size,
            fontFamily: typoStyle.value.family,
            fontWeight: typoStyle.value.weight,
            textColor: typoColor.value,
            alignment: typoAlign.value,
            textTransform: typoStyle.value.transform
          }
        })
      })
    })
  })
  sketch.getSelectedDocument().sharedTextStyles = textTokens;

  // var thing = new sketch.SymbolMaster();

  // console.log(thing)


  // console.log(context);
  

    //reference the Sketch Document
    // var doc = context.document;
  
    //reference all the pages in the document in an array
    // var pages = [doc];

    // console.log(pages);
    

  // var document = sketch.getSelectedDocument()

  // var selectedLayers = document.selectedLayers
  // var selectedCount = selectedLayers.length

  // if (selectedCount === 0) {
  //   console.log('No layers are selected.')
  // } else {
  //   console.log('Selected layers:');
  //   selectedLayers.forEach(function (layer, i) {
  //     console.log((i + 1) + '. ' + layer.name)
  //   })
  // }

};


// const buildTokens = (colorSet, prefix='') => {

//   const tokenSet = [];
  
//   for (const key in colorSet) {
//     if (colorSet.hasOwnProperty(key)) {
//       const element = colorSet[key];
      
//       if (typeof element !== 'object') continue;

//       if (element.value != null){


//         tokenSet.push({
//             name: prefix+key,
//             color: element.value
//           })
//         // add current name to set+value
//       }else{
//         tokenSet.push(buildTokens(element, prefix+key+'-'))
//       }
//     }
//   }

//   return tokenSet.flat()
// }


const cssNameToSketch = (string) => {
  const substrings = string.split('-').map(substring => stringCapitalizeFistLetter(substring))
  return substrings.join(' / ')
}


const stringCapitalizeFistLetter = string => string.charAt(0).toUpperCase() + string.slice(1)
